import java.math.BigDecimal;
import java.math.RoundingMode;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Scanner;

// =============================================================================
//  CityRide Lite
//  - Active passenger session (type + optional name)
//  - Add / list / filter / daily summary
//  - Totals by passenger type (pre-discount, post-discount, charged, cap reached)
//  - Category counts (peak/off-peak + zone involvement + route pair counts)
//  - Remove journey recalculates charges properly
// =============================================================================


// =============================================================================
//  CityRideDataset
// =============================================================================
final class CityRideDataset {
    private CityRideDataset() {}

    public static final int MIN_ZONE = 1;
    public static final int MAX_ZONE = 5;

    public enum TimeBand { PEAK, OFF_PEAK }
    public enum PassengerType { ADULT, STUDENT, CHILD, SENIOR_CITIZEN }

    public static final Map<PassengerType, BigDecimal> DISCOUNT_RATE = Map.of(
            PassengerType.ADULT,          new BigDecimal("0.00"),
            PassengerType.STUDENT,        new BigDecimal("0.25"),
            PassengerType.CHILD,          new BigDecimal("0.50"),
            PassengerType.SENIOR_CITIZEN, new BigDecimal("0.30")
    );

    public static final Map<PassengerType, BigDecimal> DAILY_CAP = Map.of(
            PassengerType.ADULT,          new BigDecimal("8.00"),
            PassengerType.STUDENT,        new BigDecimal("6.00"),
            PassengerType.CHILD,          new BigDecimal("4.00"),
            PassengerType.SENIOR_CITIZEN, new BigDecimal("7.00")
    );

    public static final Map<String, BigDecimal> BASE_FARE = buildBaseFare();

    public static BigDecimal getBaseFare(int from, int to, TimeBand band) {
        return BASE_FARE.get(key(from, to, band));
    }

    public static String key(int f, int t, TimeBand b) { return f + "-" + t + "-" + b.name(); }

    private static BigDecimal money(String a) { return new BigDecimal(a).setScale(2, RoundingMode.HALF_UP); }

    private static Map<String, BigDecimal> buildBaseFare() {
        Map<String, BigDecimal> m = new HashMap<>();

        // Peak
        put(m,1,1,TimeBand.PEAK,"2.50"); put(m,1,2,TimeBand.PEAK,"3.20"); put(m,1,3,TimeBand.PEAK,"3.80"); put(m,1,4,TimeBand.PEAK,"4.40"); put(m,1,5,TimeBand.PEAK,"5.00");
        put(m,2,1,TimeBand.PEAK,"3.20"); put(m,2,2,TimeBand.PEAK,"2.30"); put(m,2,3,TimeBand.PEAK,"3.10"); put(m,2,4,TimeBand.PEAK,"3.80"); put(m,2,5,TimeBand.PEAK,"4.50");
        put(m,3,1,TimeBand.PEAK,"3.80"); put(m,3,2,TimeBand.PEAK,"3.10"); put(m,3,3,TimeBand.PEAK,"2.10"); put(m,3,4,TimeBand.PEAK,"3.00"); put(m,3,5,TimeBand.PEAK,"3.70");
        put(m,4,1,TimeBand.PEAK,"4.40"); put(m,4,2,TimeBand.PEAK,"3.80"); put(m,4,3,TimeBand.PEAK,"3.00"); put(m,4,4,TimeBand.PEAK,"2.00"); put(m,4,5,TimeBand.PEAK,"2.90");
        put(m,5,1,TimeBand.PEAK,"5.00"); put(m,5,2,TimeBand.PEAK,"4.50"); put(m,5,3,TimeBand.PEAK,"3.70"); put(m,5,4,TimeBand.PEAK,"2.90"); put(m,5,5,TimeBand.PEAK,"1.90");

        // Off-peak
        put(m,1,1,TimeBand.OFF_PEAK,"2.00"); put(m,1,2,TimeBand.OFF_PEAK,"2.70"); put(m,1,3,TimeBand.OFF_PEAK,"3.20"); put(m,1,4,TimeBand.OFF_PEAK,"3.70"); put(m,1,5,TimeBand.OFF_PEAK,"4.20");
        put(m,2,1,TimeBand.OFF_PEAK,"2.70"); put(m,2,2,TimeBand.OFF_PEAK,"1.90"); put(m,2,3,TimeBand.OFF_PEAK,"2.60"); put(m,2,4,TimeBand.OFF_PEAK,"3.20"); put(m,2,5,TimeBand.OFF_PEAK,"3.80");
        put(m,3,1,TimeBand.OFF_PEAK,"3.20"); put(m,3,2,TimeBand.OFF_PEAK,"2.60"); put(m,3,3,TimeBand.OFF_PEAK,"1.70"); put(m,3,4,TimeBand.OFF_PEAK,"2.50"); put(m,3,5,TimeBand.OFF_PEAK,"3.10");
        put(m,4,1,TimeBand.OFF_PEAK,"3.70"); put(m,4,2,TimeBand.OFF_PEAK,"3.20"); put(m,4,3,TimeBand.OFF_PEAK,"2.50"); put(m,4,4,TimeBand.OFF_PEAK,"1.60"); put(m,4,5,TimeBand.OFF_PEAK,"2.40");
        put(m,5,1,TimeBand.OFF_PEAK,"4.20"); put(m,5,2,TimeBand.OFF_PEAK,"3.80"); put(m,5,3,TimeBand.OFF_PEAK,"3.10"); put(m,5,4,TimeBand.OFF_PEAK,"2.40"); put(m,5,5,TimeBand.OFF_PEAK,"1.50");

        return Map.copyOf(m);
    }

    private static void put(Map<String,BigDecimal> m, int f, int t, TimeBand b, String a) {
        m.put(key(f,t,b), money(a));
    }
}


// =============================================================================
// Journey
// =============================================================================
class Journey {
    private static int counter = 1;

    private int id;
    private String date;
    private int fromZone;
    private int toZone;
    private int zonesCrossed;

    private CityRideDataset.PassengerType passengerType;
    private CityRideDataset.TimeBand timeBand;

    private BigDecimal baseFare;
    private BigDecimal discountAmount;
    private BigDecimal discountedFare;
    private BigDecimal chargedFare;

    public Journey(String date, int fromZone, int toZone,
                   CityRideDataset.PassengerType passengerType,
                   CityRideDataset.TimeBand timeBand) {
        this.id = counter++;
        this.date = date;
        this.fromZone = fromZone;
        this.toZone = toZone;
        this.passengerType = passengerType;
        this.timeBand = timeBand;

        this.zonesCrossed = Math.abs(toZone - fromZone) + 1;

        this.baseFare = CityRideDataset.getBaseFare(fromZone, toZone, timeBand);

        BigDecimal rate = CityRideDataset.DISCOUNT_RATE.get(passengerType);
        this.discountAmount = baseFare.multiply(rate).setScale(2, RoundingMode.HALF_UP);

        this.discountedFare = baseFare.subtract(discountAmount).setScale(2, RoundingMode.HALF_UP);

        // chargedFare is set by manager after cap check
        this.chargedFare = discountedFare;
    }

    public static void resetCounter() { counter = 1; }

    public int getId() { return id; }
    public String getDate() { return date; }
    public int getFromZone() { return fromZone; }
    public int getToZone() { return toZone; }
    public int getZonesCrossed() { return zonesCrossed; }
    public CityRideDataset.PassengerType getPassengerType() { return passengerType; }
    public CityRideDataset.TimeBand getTimeBand() { return timeBand; }

    public BigDecimal getBaseFare() { return baseFare; }
    public BigDecimal getDiscountAmount() { return discountAmount; }
    public BigDecimal getDiscountedFare() { return discountedFare; }
    public BigDecimal getChargedFare() { return chargedFare; }

    public void setChargedFare(BigDecimal chargedFare) {
        this.chargedFare = chargedFare;
    }

    public boolean involvesZone(int zone) {
        return fromZone == zone || toZone == zone;
    }

    public void display() {
        System.out.println(
                "ID:" + id +
                        " Date:" + date +
                        " From:" + fromZone +
                        " To:" + toZone +
                        " Band:" + timeBand +
                        " Passenger:" + passengerType +
                        " Zones:" + zonesCrossed +
                        " Base:£" + baseFare +
                        " Disc:£" + discountedFare +
                        " Charged:£" + chargedFare
        );
    }
}


// =============================================================================
//   CityRideManager
// =============================================================================
class CityRideManager {
    private List<Journey> journeys = new ArrayList<>();

    // Active session
    private String sessionName;
    private CityRideDataset.PassengerType sessionPassengerType;

    // Running totals for caps
    private Map<CityRideDataset.PassengerType, BigDecimal> runningTotals = new HashMap<>();

    public CityRideManager(String sessionName, CityRideDataset.PassengerType sessionPassengerType) {
        this.sessionName = sessionName;
        this.sessionPassengerType = sessionPassengerType;
        resetTotalsOnly();
    }

    public String getSessionName() { return sessionName; }
    public CityRideDataset.PassengerType getSessionPassengerType() { return sessionPassengerType; }

    public void setSessionPassenger(String name, CityRideDataset.PassengerType type) {
        this.sessionName = name;
        this.sessionPassengerType = type;
    }

    private void resetTotalsOnly() {
        runningTotals.clear();
        CityRideDataset.PassengerType[] types = CityRideDataset.PassengerType.values();
        for (int i = 0; i < types.length; i++) {
            runningTotals.put(types[i], BigDecimal.ZERO);
        }
    }

    // ADD JOURNEY
    public void addJourney(String date, int from, int to, CityRideDataset.TimeBand band) {
        CityRideDataset.PassengerType type = sessionPassengerType;

        Journey j = new Journey(date, from, to, type, band);

        // cap logic
        BigDecimal cap = CityRideDataset.DAILY_CAP.get(type);
        BigDecimal current = runningTotals.get(type);
        BigDecimal discounted = j.getDiscountedFare();

        BigDecimal charged;
        if (current.compareTo(cap) >= 0) {
            charged = BigDecimal.ZERO;
        } else if (current.add(discounted).compareTo(cap) > 0) {
            charged = cap.subtract(current);
        } else {
            charged = discounted;
        }

        charged = charged.setScale(2, RoundingMode.HALF_UP);
        j.setChargedFare(charged);

        runningTotals.put(type, current.add(charged));
        journeys.add(j);

        System.out.println("Journey added! Charged: £" + charged);
    }

    //  LIST JOURNEYS
    public void listAllJourneys() {
        if (journeys.isEmpty()) {
            System.out.println("No journeys recorded.");
            return;
        }
        System.out.println("\n--- All Journeys ---");
        for (int i = 0; i < journeys.size(); i++) {
            journeys.get(i).display();
        }
    }

    //  FILTER JOURNEY
    public void filterByPassengerType(CityRideDataset.PassengerType type) {
        List<Journey> results = new ArrayList<>();
        for (int i = 0; i < journeys.size(); i++) {
            Journey j = journeys.get(i);
            if (j.getPassengerType() == type) results.add(j);
        }
        printFiltered(results, "Passenger type: " + type);
    }

    public void filterByTimeBand(CityRideDataset.TimeBand band) {
        List<Journey> results = new ArrayList<>();
        for (int i = 0; i < journeys.size(); i++) {
            Journey j = journeys.get(i);
            if (j.getTimeBand() == band) results.add(j);
        }
        printFiltered(results, "Time band: " + band);
    }

    public void filterByZone(int zone) {
        List<Journey> results = new ArrayList<>();
        for (int i = 0; i < journeys.size(); i++) {
            Journey j = journeys.get(i);
            if (j.involvesZone(zone)) results.add(j);
        }
        printFiltered(results, "Zone involved: " + zone);
    }

    public void filterByDate(String date) {
        List<Journey> results = new ArrayList<>();
        for (int i = 0; i < journeys.size(); i++) {
            Journey j = journeys.get(i);
            if (j.getDate().equalsIgnoreCase(date)) results.add(j);
        }
        printFiltered(results, "Date: " + date);
    }

    private void printFiltered(List<Journey> results, String label) {
        System.out.println("\n--- Filter Results (" + label + ") ---");
        if (results.isEmpty()) {
            System.out.println("No journeys found.");
            return;
        }
        for (int i = 0; i < results.size(); i++) {
            results.get(i).display();
        }
    }
    //  REMOVE JOURNEY
    public void removeJourney(int id) {
        Journey toRemove = null;
        for (int i = 0; i < journeys.size(); i++) {
            if (journeys.get(i).getId() == id) {
                toRemove = journeys.get(i);
                break;
            }
        }

        if (toRemove == null) {
            System.out.println("No journey with ID " + id);
            return;
        }

        journeys.remove(toRemove);

        rebuildAllCharges();

        System.out.println("Journey removed and totals recalculated.");
    }
    private void rebuildAllCharges() {
        resetTotalsOnly();

        // Recalculate chargedFare for every journey in the remaining list
        for (int i = 0; i < journeys.size(); i++) {
            Journey j = journeys.get(i);
            CityRideDataset.PassengerType type = j.getPassengerType();

            BigDecimal cap = CityRideDataset.DAILY_CAP.get(type);
            BigDecimal current = runningTotals.get(type);
            BigDecimal discounted = j.getDiscountedFare();

            BigDecimal charged;
            if (current.compareTo(cap) >= 0) {
                charged = BigDecimal.ZERO;
            } else if (current.add(discounted).compareTo(cap) > 0) {
                charged = cap.subtract(current);
            } else {
                charged = discounted;
            }

            charged = charged.setScale(2, RoundingMode.HALF_UP);
            j.setChargedFare(charged);
            runningTotals.put(type, current.add(charged));
        }
    }

   
